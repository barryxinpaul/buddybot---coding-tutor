/**
 * Grit v0.2.5
 * Copyright (C) 2011 Matt Baker
 * http://github.com/reissbaker
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License at <http://www.gnu.org/licenses/> for 
 * details.
 */  

(function() {

  /**
   * GRIT
   * ====
   *
   * Grit is the Model third of the traditional Model-View-Controller
   * webapp trinity. It's asynchronous and evented, and usable both
   * in the browser and in Node.js; think of it as a leaner Backbone
   * with a more Node-friendly API.
   *
   * Grit has a single hard dependency, but only in browsers: it needs
   * an implementation of EventEmitter stored on window.EventEmitter.
   * A recommended EventEmitter implementation can be found 
   * [here](https://github.com/Wolfy87/EventEmitter).
   *
   * On Node.js servers, Grit has no dependencies.
   *
   * Some may find Grit's Node-inspired callback system clunky or
   * undesirable; [glow](https://github.com/reissbaker/glow), a 
   * [Heavy Flow](https://github.com/reissbaker/heavy-flow)-based flow 
   * control plugin for Grit, comes highly recommended.
   */

  var Grit, PROP_CHANGE_EVENT, Placeholder, placeholder, Node, Collection, 
      EventEmitter, exported, argArray, mergeDict, ensureModelClassInit,
      parseArgs, handleEnv, undef;
  
  // helps with environment-specific code
  handleEnv = function(node, browser) {
    if(exports !== undef && module !== undef && require !== undef)
      return node();
    return browser();
  };

  // find an EventEmitter implementation
  EventEmitter = handleEnv(
    function() { return require('events').EventEmitter; }, 
    function() { return window.EventEmitter;}
  );

  /**
   * basic utility functions
   * -----------------------
   */

  // turns an argument object into an argument array
  argArray = function(argObj) {
    return Array.prototype.slice.call(argObj, 0);
  };

  // merges two hashes. the second hash will override
  // the first if there are collisions.
  mergeDict = function(d1, d2) {
    var dict, prop;
    dict = {};
    for(prop in d1)
      if(d1.hasOwnProperty(prop))
        dict[prop] = d1[prop];
    for(prop in d2)
      if(d2.hasOwnProperty(prop))
        dict[prop] = d2[prop];
    return dict;
  };

  // simple fluent DSL for parsing arguments.
  parseArgs = function(args) {
    var nextToParse = 0;
    args = argArray(args);
    return {
      parsed: {},

      optional: function(name, defaultValue, options) {
        var passed, curr, value;

        passed = true;
        curr = args[nextToParse];
        value = defaultValue;

        if(typeof options === 'function') {
          passed = options(curr, args);
        } else {
          if(options.hasOwnProperty('type'))
            passed = typeof curr === options.type;
          if(options.hasOwnProperty('instance'))
            passed = passed && curr instanceof options.instance;
        }

        if(passed) {
          nextToParse++;
          value = curr;
        }
        
        this.parsed[name] = value;
        return this;
      },
      required: function(name) {
        this.parsed[name] = args[nextToParse];
        nextToParse++;
        return this;
      }
    };
  };

  /**
   * helpers
   * -------
   */

  ensureModelClassInit = function(ModelClass) {
    if(!ModelClass.hasOwnProperty('hasList') || !ModelClass.hasList) {
      ModelClass.hasList = {};
      ModelClass.hasListLength = 0;
    }
    if(!ModelClass.hasOwnProperty('reqs') || !ModelClass.reqs) {
      ModelClass.reqs = {};
      ModelClass.reqsLength = 0;
    }
  };

  PROP_CHANGE_EVENT = 'propertyChange';

  /**
   * The model class
   * ===============
   */

  Grit = function() {
    var data, prop, valid, changeData, 
        validateData, ensurePresenceOfData,
        properties, isNew, finishedCreating,
        args, constructing;

    EventEmitter.call(this);
    args = parseArgs(arguments)
            .optional('properties', {}, {type: 'object'})
            .optional('isNew', true, {type: 'boolean'})
            .optional('finishedCreating', function(){}, {type: 'function'})
            .parsed;

    data = {};
    constructing = true;

    /** 
     * helper functions
     * ----------------
     */

    // checks if all `required` data is present
    ensurePresenceOfData = function(that) {
      var prop;
      if(!that.constructor.hasOwnProperty('reqs') || !that.constructor.reqs)
        return true;

      for(prop in that.constructor.reqs) {
        if(that.constructor.reqs.hasOwnProperty(prop) && !data.hasOwnProperty(prop))
          return false;
      }
      return true;
    };

    // checks if the value is valid for the property
    validateData = function(that, name, value) {
      var validators, valid, index, length;
      if(!that.constructor.hasOwnProperty('validations') || !that.constructor.validations)
        return true;
      if(!that.constructor.validations.hasOwnProperty(name) || !that.constructor.validations[name])
        return true;
      else {
        validators = that.constructor.validations[name];
        for(index = 0, length = validators.length; index < length; index++) {
          if(!validators[index](value))
            return false;
        }
      }
      return true;
    };

    // changes the data, emitting the appropriate events and calling the callbacks
    changeData = function(that, name, value, silent, finished) {
      var changeEvent;
      if(silent === undef || !silent) {
        that.get(name, function(err, oldValue) {
          data[name] = value;
          if(!constructing) {
            changeEvent = 'change:' + name;
            that.emit(changeEvent, that, oldValue, value);
            that.emit(PROP_CHANGE_EVENT, changeEvent, that, oldValue, value);
          }
          if(!constructing)
            that.constructor.update(that, data, name, finished);
        });
      } else {
        data[name] = value;
        if(!constructing)
          that.constructor.update(that, data, name, finished);
      }
    };

    /** 
     * priveleged instance methods
     * ---------------------------
     */

    // gets a named property and passes it to the callback
    this.get = function(name, callback) {
      if(data.hasOwnProperty(name))
        callback(null, data[name]);
      else {
        this.constructor.read(this, data, name, function(err, value) {
          if(!err)
            data[name] = value;
          callback(err, value);
        }); 
      }
    };

    // loads all properties specified in 'has' and 'required'
    this.loadAll = function(finished) {
      var propsToLoad, prop, load, calledFinish, callFinish, that, allProps;

      that = this;
      ensureModelClassInit(this.constructor);
      propsToLoad = this.constructor.hasListLength + this.constructor.reqsLength;
      allProps = mergeDict(this.constructor.hasList, this.constructor.reqs);
      calledFinish = false;
      
      callFinish = function(err) {
        if(err === undef)
          err = null;
        if(!calledFinish) {
          calledFinish = true;
          if(finished !== undef)
            finished(err);
        }
      };

      load = function(prop) {
        that.constructor.read(that, data, prop, function(err, value) {
          if(!err) {
            data[prop] = value;
            propsToLoad--;
            if(propsToLoad === 0)
              callFinish();
          }
          else {
            callFinish(err);  
          }
        });
      };

      for(prop in allProps) {
        if(this.constructor.hasList.hasOwnProperty(prop)) {
          if(!data.hasOwnProperty(prop)) {
            load(prop);
          }
        }
      } 

      if(propsToLoad === 0)
        callFinish();
    };

    // sets a named property to a value. silent is an optional boolean to stifle all 'change' callbacks.
    // finished is the callback that gets called once the property's been successfully or unsuccessfully set.
    this.set = function() {
      var args = parseArgs(arguments)
              .required('name')
              .required('value')
              .optional('silent', false, {type: 'boolean'})
              .optional('finished', function(){}, {type: 'function'})
              .parsed;

      var valid = validateData(this, args.name, args.value) && ensurePresenceOfData(this);

      if(valid)
        changeData(this, args.name, args.value, args.silent, args.finished);
      else
        args.finished('Error: ' + args.value + ' is an invalid value for ' + args.name + ' of ' + this);
    };

    // destroys the object by proxying out to the class's destroy method.
    this.destroy = function(callback) {
      if(callback === undef)
        callback = function(){};
      this.constructor.destroy(this, data, callback);
    };

    /**
     * setting the initial data from the defaults and
     * the properties passed in
     * ------------------------
     */

    if(this.constructor.hasOwnProperty('defaultsHash') && args.isNew) {
      for(prop in this.constructor.defaultsHash) {
        if(this.constructor.defaultsHash.hasOwnProperty(prop) && !args.properties.hasOwnProperty(prop))
          args.properties[prop] = this.constructor.defaultsHash[prop];
      }
    }

    // check validity
    valid = true;
    if(this.constructor.hasOwnProperty('reqs')) {
      for(prop in this.constructor.reqs) {
        if(!args.properties.hasOwnProperty(prop) || !validateData(this, prop, args.properties[prop])) {
          valid = false;
          break;
        }
      }
    } 

    // set the defaults for things not being overridden; otherwise, set the properties
    if(valid)
      for(prop in args.properties)
        if(args.properties.hasOwnProperty(prop))
          changeData(this, prop, args.properties[prop], constructing, function(){});

    this.constructor.create(this, data, args.finishedCreating);
    constructing = args.isNew = false;
  };

  /** 
   * inheritance
   * -----------
   */

  Grit.prototype = new EventEmitter();
  Grit.prototype.constructor = Grit;

  // extends a model
  Grit.extend = function(structFn) {
    structFn.prototype = new Grit();
    structFn.prototype.constructor = structFn;
    for(var prop in Grit) {
      if(Grit.hasOwnProperty(prop))
        structFn[prop] = Grit[prop];
    }
    return structFn;
  };

  /**
   * sync functions
   * --------------
   */

  Grit.create = function(model, data, callback) {
    if(callback !== undef)
      callback(null);
  };
  Grit.read = function(model, data, property, callback) {
    callback('Error: no ' + property + ' property could be read', null);
  };
  Grit.update = function(model, data, property, callback) {
    callback(null);
  };
  Grit.destroy = function(model, data, callback) {
    callback(null);
  };
  Grit.find = function(findArg, callback) {
    callback('Error: find must be overridden.', null);
  };

  /**
   * Property defaults, assertions
   * -----------------------------
   */

  Grit.defaults = function(properties) {
    if(!this.hasOwnProperty('defaultsHash'))
      this.defaultsHash = {};
    for(var prop in properties)
      if(properties.hasOwnProperty(prop))
        this.defaultsHash[prop] = properties[prop];
  };

  // lists properties as required for validation.
  Grit.required = function() {
    var args, index; 
    args = argArray(arguments);
    ensureModelClassInit(this);

    for(index = 0; index < args.length; index++) {
      this.reqs[args[index]] = true;
      this.reqsLength++;
    }

    if(args.length === 1)
      return args[0];
  };

  // unlists properties as required for validation.
  Grit.unrequired = function() {
    var args, index;
    args = argArray(arguments);

    if(!this.hasOwnProperty('reqs'))
      return;

    for(index = 0; index < args.length; index++) {
      if(this.reqs.hasOwnProperty(args[index])) {
        delete this.reqs[args[index]];
        this.reqsLength--;
      }
    }

    if(args.length === 1)
      return args[0];
  };

  // lists properties as belonging to the model.
  // all properties should be listed using `has`.
  Grit.has = function() {
    var args, index;
    args = argArray(arguments);
    ensureModelClassInit(this);
    
    for(index = 0; index < args.length; index++) {
      this.hasList[args[index]] = true;
      this.hasListLength++;
    }

    if(args.length === 1)
      return args[0];
  };

  // unlists properties as belonging to the model.
  Grit.lacks = function() {
    var args, index;
    args = argArray(arguments);

    if(!this.hasOwnProperty('hasList'))
      return;

    for(index = 0; index < args.length; index++) {
      if(this.hasList.hasOwnProperty(args[index])) {
        delete this.hasList[args[index]];
        this.hasListLength--;
      }
    }

    if(args.length === 1)
      return args[0];
  };

  // assigns a validation function to a named property
  Grit.validate = function(name, validator) {
    if(!this.hasOwnProperty('validations'))
      this.validations = {};

    if(!this.validations.hasOwnProperty(name))
      this.validations[name] = [];
    this.validations[name].push(validator);
  };

  // unassigns a validation function from a named property
  Grit.removeValidation = function(name, validator) {
    var validators, index, length;
    if(!this.hasOwnProperty('validations'))
      return;

    if(this.validations.hasOwnProperty(name)) {
      validators = this.validations[name];
      for(index = 0, length = validators.length; index < length; index++) {
        if(validators[index] === validator) {
          validators.splice(index, 1);
          break;
        }
      }

      if(validators.length === 0)
        delete this.validations[name];
    }
  };


  /**
   * Placeholder class
   * -----------------
   *
   * Can be given to Collections instead of models.
   * Will attempt to load the corresponding model
   * when accessed through the Collection, and will
   * replace itself with the model once loaded.
   */

  Placeholder = function(findArg, ModelClass) {
    this.load = function(callback) {
      ModelClass.find(findArg, callback);
    };
  };

  // builder function
  placeholder = function(findArg, ModelClass) {
    return new Placeholder(findArg, ModelClass);
  };


  /**
   * Node class
   * ==========
   * Helper for Collections
   */

  Node = function(element) {
    this.element = element;
  };


  /**
   * Collection class
   * ================
   * Holds collections of Models, or Placeholders
   * of Models. Binds and forwards change events
   * from Models in the collection, and emits
   * add and remove events when Models are added
   * to or removed from the collection.
   */

  Collection = function(elements) {
    var data, loadElement, access, added, removed, 
        buildPopFn, removal, buildPushFn, insertion,
        forwardEvent, that;
    EventEmitter.call(this);
    that = this;

    if(elements === undef)
      data = [];
    else
      data = elements.splice(0);
    
    /**
     * Local helper functions
     * ----------------------
     */

    // loads an element if it's a placeholder;
    // otherwise, just sends the element back
    loadElement = function(element, callback) {
      if(!(element instanceof Placeholder))
        callback(null, element);
      else
        element.load(callback);
    };

    // accesses a node. if forceLoad is true, it'll
    // load the element if necessary and save it to
    // the local cache.
    access = function(node, forceLoad, callback) {
      if(forceLoad) {
        loadElement(node.element, function(err, element) {
          if(!err && element)
            node.element = element;
          if(typeof callback === 'function')
            callback(err, element);
        });
      } else {
        callback(null, node.element);
      }
    };

    // emitters
    added = function(that, ele) {
      that.emit('add', ele);
    };
    removed = function(that, ele) {
      that.emit('remove', ele);
    };

    // gets bound to Models, forwards their propertyChange events
    forwardEvent = function(changeEvent, model, oldValue, newValue) {
      that.emit(changeEvent, model, oldValue, newValue);
      that.emit(PROP_CHANGE_EVENT, changeEvent, model, oldValue, newValue);
    };

    // inserts a node into the dataset, using an arbitrary insertion function.
    // if forceLoad is true, it'll load the element if necessary -- otherwise,
    // it may give Placeholders to the callbacks.
    insertion = function(that, forceLoad, node, callback, addFn) {
      var ele = node.element;
      addFn(node);
      if(ele instanceof Grit)
        ele.on(PROP_CHANGE_EVENT, forwardEvent);
      added(that, ele);
      access(node, forceLoad, function(err, model) {
        callback(err, model);
      });
    };

    // removes a node from the dataset using an arbitrary remove function.
    // if forceLoad is true, it'll load the element if necessary -- otherwise
    // it may give Placeholders to the callbacks.
    removal = function(that, name, forceLoad, callback, removeFn) {
      var node, ele;
      if(data.length <= 0) {
        callback('Error: nothing to ' + name, null);
        return;
      }

      node = removeFn();
      ele = node.element;

      if(ele instanceof Grit)
        ele.removeListener(PROP_CHANGE_EVENT, forwardEvent);
      
      removed(that, ele);

      access(node, forceLoad, function(err, model) {
        callback(err, model);
      });
    };

    // builds an arbitrary pop-type function
    buildPopFn = function(that, name, removeFn) {
      return function() {
        var args = parseArgs(arguments)
                .optional('options', {forceLoad: false}, {type: 'object'})
                .required('callback')
                .parsed;
        removal(that, name, args.options.forceLoad, args.callback, removeFn);
      };
    };

    // builds an arbitrary push-type function
    buildPushFn = function(that, addFn) {
      return function() {
        var args = parseArgs(arguments)
                .optional('options', {forceLoad: false}, function(arg, all) { 
                  return all.length > 1 && typeof arg === 'object'; 
                })
                .required('element')
                .optional('callback', function(){}, {type: 'function'})
                .parsed;

        insertion(that, args.options.forceLoad, new Node(args.element), args.callback, addFn);
      };
    };


    /**
     * Priveleged instance methods
     * ---------------------------
     */

    /**
     * push
     * ----
     * takes an optional options hash, an element (either a Placeholder or a Model), and
     * an optional callback of the form `function(err, model)`.
     *
     * pushes the element into the dataset. if an options hash is provided and its `forceLoad`
     * key is true, will load any Placeholders given into full Models and save them to the
     * local cache. the callback gets
     * called once the loading is complete, or as soon as the data is pushed if no loading
     * is done.
     */

    this.push = buildPushFn(this, function(node) { data.push(node); });

    /**
     * pop
     * ---
     * takes an optional options hash and an optional callback of the form `function(err, model)`.
     *
     * pops the last element in the collection and passes it to the callback (or passes an
     * error message if unsuccessful). if an options hash is provided and its `forceLoad` key
     * is true, will load any Placeholders popped into full Models. the callback gets called
     * once the loading is complete, or as soon as the data is popped if no loading is done.
     */

    this.pop = buildPopFn(this, 'pop', function() { return data.pop(); });

    /**
     * pushFront/popFront
     * ------------------
     * exactly the same as push and pop, except from the front of the collection instead of
     * from the back.
     */

    this.pushFront = buildPushFn(this, function(node) { data = [node].concat(data); });
    this.popFront = buildPopFn(this, 'popFront', function() { return data.splice(0, 1)[0]; });

    /**
     * set
     * ---
     * takes an index, an optional options hash, an element, and an optional callback of the form 
     * `function(err, model, removed)`.
     *
     * sets the element into the collection at the given index. if something already existed
     * at that index, it will be removed and its remove event will be fired. if an options hash
     * is provided and its `forceLoad` key is true, any Placeholders given or found will be loaded
     * into full Models -- including the removed items. only the added item will be saved to the 
     * local cache, however. the callback gets called once all of the
     * loading is complete, or as soon as the data is written if no loading is done.
     */

    this.set = function() {
      var that, args, index, defaultOptions, node, addFn, curr;
      that = this;
      args = parseArgs(arguments)
              .required('index')
              .optional('options', {forceLoad: false}, function(arg, all) {
                var l = all.length;
                return l > 2 && (l === 4 ? true : typeof all[l - 1] !== 'function');
              })
              .required('element')
              .optional('callback', function(){}, {type: 'function'})
              .parsed;

      index = args.index;
      node = new Node(args.element);
      addFn = function(node) { data[index] = node; };

      if(data[index] !== undef && data[index]) {
        curr = data[index];
        removal(this, 'set', args.options.forceLoad, function(err, removed) {
          insertion(that, args.options.forceLoad, node, function(err, model) {
            args.callback(err, model, removed);
          }, addFn);
        }, function() { return curr; });
      } else {
        insertion(this, args.options.forceLoad, node, args.callback, addFn);
      }
    };

    /**
     * remove
     * ------
     * takes either an index, model, or placeholder, an optional options hash, and an optional 
     * callback of the form `function(err, model)`.
     *
     * if given an index, removes the item at that index. if given a placeholder or a model,
     * finds the placeholder or model in the collection and removes it. it will only remove
     * _one_ instance of the placeholder or model -- if the collection contains duplicates,
     * you must call this method multiple times (change this behavior?).
     *
     * if given an options hash with a `forceLoad` key set to true, will load any Placeholders
     * found into full Models and save them to the local cache. BE AWARE: if given a Model as the 
     * first parameter and an options 
     * hash with the `forceLoad` key set to true, it will load the ENTIRE DATASET when it
     * searches for matches.
     *
     * the callback will be called once any loading done is complete, or if no loading is done,
     * as soon as the data is removed.
     */

    this.remove = function() {
      var that, args, index, model, defaultOptions, removalArg;
      that = this;
      args = parseArgs(arguments)
              .required('something')
              .optional('options', {forceLoad: false, inOrder: true}, {type: 'object'})
              .optional('callback', function(){}, {type: 'function'})
              .parsed;
      
      if(typeof args.something === 'number') {
        index = args.something;
      } else {
        model = args.something;
        index = -1;
        this.forEach(args.options, function(err, m, i) {
          if(m === model)
            index = i;
        }, function() {
          if(index === -1)
            args.callback('Error: model not found', null);
          else
            that.remove(index, args.callback);
        });
        return;
      }

      removal(this, 'remove', args.options.forceLoad, args.callback, function() { return data.splice(index, 1)[0]; });
    };

    /**
     * at
     * ---
     * takes an index, an optional options hash, and a callback of the form `function(err, model)`.
     *
     * passes the element at the given index to the callback, if found -- otherwise passes an
     * error message. if an options hash is provided and its `forceLoad` key is set to true, will
     * load any Placeholders found into full Models and save them to the local cache.
     */

    this.at = function() {
      var args = parseArgs(arguments)
                  .required('index')
                  .optional('options', {forceLoad:false}, {type: 'object'})
                  .optional('callback', function(){}, {type: 'function'})
                  .parsed;
      access(data[args.index], args.options.forceLoad, args.callback);
    };

    /**
     * length
     * ------
     * returns the size of the dataset.
     */

    this.length = function() {
      return data.length;
    };

    /**
     * forEach
     * -------
     * takes an optional options hash, a function of the form `function(err, model, index)` to
     * run on each element in the collection, and an optional callback.
     *
     * runs the function passed in on every element in the dataset, and calls the callback (if
     * provided) once completed. if an options hash is passed in and its `forceLoad` key is set
     * to true, any Placeholders seen will be loaded into full Models and stored in the local
     * cache. Be aware: this will load the entire dataset into memory.
     *
     * if an options hash is provided and its `inOrder` key is set to true, will make sure to
     * run the functions in order, even if some are synchronous and others async. otherwise,
     * the functions may run out of order -- however, the `index` parameter passed in will still
     * always be correct.
     */

    this.forEach = function() {
      var args, defaultOptions, itrOneOrdered, itrOneUnordered, index, asyncFns;
      asyncFns = 0;
      args = parseArgs(arguments)
              .optional('options', {forceLoad: false, inOrder: false}, {type: 'object'})
              .required('fn')
              .optional('callback', function(){}, {type: 'function'})
              .parsed;

      itrOneOrdered = function(index, options, fn, finishedCallback) {
        if(index < data.length) {
          access(data[index], options.forceLoad, function(err, ele) {
            fn(err, ele, index);
            itrOneOrdered(index+1, options, fn, finishedCallback);
          });
        } else
          finishedCallback();
      };
      itrOneUnordered = function(index, options, fn, finishedCallback) {
        access(data[index], options.forceLoad, function(err, ele) {
          asyncFns--;
          fn(err, ele, index);
          if(asyncFns === 0)
            finishedCallback();
        });
      };

      if(!args.options.inOrder) {
        if(data.length > 0) {
          asyncFns = data.length;
          for(index = 0; index < data.length; index++)
            itrOneUnordered(index, args.options, args.fn, args.callback);
        } else
          args.callback();
      } else
        itrOneOrdered(0, args.options, args.fn, args.callback);
    };
  };


  /**
   * inheritance
   * -----------
   */

  Collection.prototype = new EventEmitter();
  Collection.prototype.constructor = Collection;


  /** 
   * Export
   * ======
   */

  exported = {
    Model: Grit,
    Collection: Collection,
    placeholder: placeholder
  };

  handleEnv(
    function() { module.exports = exported; },
    function() { window.grit = exported; }
  );

}());
