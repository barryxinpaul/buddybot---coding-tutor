(function() {
  var Collection, Model, assert, exports, grit, placeholder, vows;

  vows = require('vows');

  assert = require('assert');

  grit = require('../index.js');

  Collection = grit.Collection;

  Model = grit.Model;

  placeholder = grit.placeholder;

  exports = module.exports = function(suite) {
    return suite.addBatch({
      'Collections': {
        topic: function() {
          return Collection;
        },
        'should start empty': function(Collection) {
          var collection;
          collection = new Collection();
          return assert.equal(collection.length(), 0);
        },
        'should push to the back': function(Collection) {
          var collection, equal, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.push(model);
          equal = false;
          collection.at(1, function(err, m) {
            return equal = m === model;
          });
          return assert.isTrue(equal);
        },
        'should pop from the back': function(Collection) {
          var collection, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.push(model);
          return collection.pop(function(err, m) {
            return assert.equal(m, model);
          });
        },
        'should mutate the collection to remove the object being popped': function(Collection) {
          var collection, model;
          collection = new Collection();
          model = new Model();
          collection.push(model);
          return collection.pop(function(err, m) {
            return assert.equal(collection.length(), 0);
          });
        },
        'should push to the front when using pushFront': function(Collection) {
          var collection, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.pushFront(model);
          return collection.at(0, function(err, m) {
            return assert.equal(model, m);
          });
        },
        'should pop from the front when using popFront': function(Collection) {
          var collection, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.pushFront(model);
          return collection.popFront(function(err, m) {
            return assert.equal(model, m);
          });
        },
        'should remove from the correct spot when using remove with an index': function(Collection) {
          var collection, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.push(model);
          collection.push(new Model());
          return collection.remove(1, function(err, m) {
            return assert.equal(model, m);
          });
        },
        'should remove the correct element when using remove with a model': function(Collection) {
          var collection, model;
          collection = new Collection();
          collection.push(new Model());
          model = new Model();
          collection.push(model);
          collection.push(new Model());
          return collection.remove(model, function(err, m) {
            return assert.equal(model, m);
          });
        },
        'remove should mutate the collection': function(Collection) {
          var collection;
          collection = new Collection();
          collection.push(new Model());
          collection.remove(0);
          return assert.equal(collection.length(), 0);
        },
        'should iterate over everything when not specifying an ordering': function(Collection) {
          var collection, numModels;
          collection = new Collection();
          collection.push(new Model());
          collection.push(new Model());
          numModels = 0;
          collection.forEach(function(err, model) {
            return numModels++;
          });
          return assert.equal(numModels, collection.length());
        },
        'should iterate over everything when specifying an ordering': function(Collection) {
          var collection, numModels;
          collection = new Collection();
          collection.push(new Model());
          collection.push(new Model());
          numModels = 0;
          collection.forEach({
            inOrder: true
          }, function(err, model) {
            return numModels++;
          });
          return assert.equal(numModels, collection.length());
        },
        'should pass the correct indices when iterating async': function(Collection) {
          var collection, correctIndex, m0, m1;
          collection = new Collection();
          m0 = new Model();
          m1 = new Model();
          collection.push(m0);
          collection.push(m1);
          correctIndex = true;
          collection.forEach(function(err, model, index) {
            return correctIndex = correctIndex && (model === m0 ? index === 0 : index === 1);
          });
          return assert.isTrue(correctIndex);
        },
        'should forward any change events from the model': function(Collection) {
          var collection, forwarded, m;
          collection = new Collection();
          m = new Model();
          collection.push(m);
          forwarded = false;
          collection.on('change:test', function(model, oldValue, newValue) {
            return forwarded = true;
          });
          m.set('test', 500);
          return assert.isTrue(forwarded);
        },
        'should forward the generic property change events': function(Collection) {
          var collection, forwarded, m;
          collection = new Collection();
          m = new Model();
          collection.push(m);
          forwarded = false;
          collection.on('propertyChange', function(evt) {
            if (evt === 'change:test') return forwarded = true;
          });
          m.set('test', 500);
          return assert.isTrue(forwarded);
        },
        'should emit add events when things are added': function(Collection) {
          var collection, emitted;
          collection = new Collection();
          emitted = false;
          collection.on('add', function() {
            return emitted = true;
          });
          collection.push(new Model());
          return assert.isTrue(emitted);
        },
        'should pass the right model to add events': function(Collection) {
          var collection, emitted, m;
          collection = new Collection();
          m = new Model();
          emitted = false;
          collection.on('add', function(model) {
            if (model === m) return emitted = true;
          });
          collection.push(m);
          return assert.isTrue(emitted);
        },
        'should emit remove events when things are removed': function(Collection) {
          var collection, emitted;
          collection = new Collection();
          emitted = false;
          collection.on('remove', function() {
            return emitted = true;
          });
          collection.push(new Model());
          collection.remove(0);
          return assert.isTrue(emitted);
        },
        'should pass the right model to remove events': function(Collection) {
          var collection, emitted, m;
          collection = new Collection();
          m = new Model();
          emitted = false;
          collection.on('remove', function(model) {
            if (model === m) return emitted = true;
          });
          collection.push(m);
          collection.remove(0);
          return assert.isTrue(emitted);
        }
      }
    });
  };

}).call(this);
