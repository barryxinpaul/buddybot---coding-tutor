(function() {
  var Model, assert, exports, grit, vows,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  vows = require('vows');

  assert = require('assert');

  grit = require('../index.js');

  Model = grit.Model;

  exports = module.exports = function(suite) {
    return suite.addBatch({
      'Model objects': {
        topic: function() {
          return Model;
        },
        'should return null for uninitialized data': function(Model) {
          var g;
          g = new Model();
          return g.get('test', function(err, value) {
            return assert.equal(value, null);
          });
        },
        'should return the correct data when accessing previously set data': function(Model) {
          var g;
          g = new Model();
          g.set('test', 500);
          return g.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should fire change events when setting data': function(Model) {
          var called, g;
          g = new Model();
          called = false;
          g.on('change:test', function() {
            return called = true;
          });
          g.set('test', 500);
          return assert.isTrue(called);
        },
        'should not fire unrelated change events when setting data': function(Model) {
          var called, g;
          g = new Model();
          called = false;
          g.on('change:nope', function() {
            return called = true;
          });
          g.set('test', 500);
          return assert.isFalse(called);
        },
        'should pass the model into change handlers as the first argument': function(Model) {
          var g;
          g = new Model();
          g.on('change:test', function(model) {
            return assert.equal(model, g);
          });
          return g.set('test', 500);
        },
        'should pass the old value into change handlers as the second argument': function(Model) {
          var g;
          g = new Model();
          g.on('change:test', function(model, oldValue) {
            return assert.equal(oldValue, null);
          });
          return g.set('test', 500);
        },
        'should pass the new value into change handlers as the third argument': function(Model) {
          var g;
          g = new Model();
          g.on('change:test', function(model, oldValue, value) {
            return assert.equal(value, 500);
          });
          return g.set('test', 500);
        },
        'should change the old value prior to a change callback': function(Model) {
          var g;
          g = new Model();
          g.on('change:test', function(model) {
            return model.get('test', function(err, value) {
              return assert.notEqual(value, null);
            });
          });
          return g.set('test', 500);
        },
        'should change the property after the change callback': function(Model) {
          var g;
          g = new Model();
          g.on('change:test', function() {});
          g.set('test', 500);
          return g.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should not emit the change event if a truthy value is passed as the silent parameter to set': function(Model) {
          var called, g;
          g = new Model();
          called = false;
          g.on('change:test', function() {
            return called = true;
          });
          g.set('test', 500, true);
          return assert.isFalse(called);
        },
        'should fire the generic propertyChanged event on every property change': function(Model) {
          var called, g;
          g = new Model();
          called = 0;
          g.on('propertyChange', function() {
            return called++;
          });
          g.set('test', 500);
          g.set('test2', 200);
          return assert.equal(called, 2);
        },
        'should pass the right event names into the generic propertyChanged handlers': function(Model) {
          var g;
          g = new Model();
          g.on('propertyChange', function(evt) {
            return assert.equal(evt, 'change:test');
          });
          return g.set('test', 500);
        },
        'should call validation functions when associated data is changed': function(Model) {
          var Derived, called, g;
          called = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.validate('test', function(value) {
            return called = true;
          });
          g = new Derived();
          g.set('test', 500);
          return assert.isTrue(called);
        },
        'should change the value being set if the validation function returns true': function(Model) {
          var Derived, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          Derived.validate('test', function(value) {
            return true;
          });
          g.set('test', 500);
          return g.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should not change the value being set if the validation function returns false': function(Model) {
          var Derived, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          Derived.validate('test', function(value) {
            return false;
          });
          g.set('test', 500);
          return g.get('test', function(err, value) {
            return assert.isNull(value);
          });
        },
        'should call the update function after setting data': function(Model) {
          var Derived, called, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          called = false;
          Derived.update = function() {
            return called = true;
          };
          g.set('test', 500);
          return assert.isTrue(called);
        },
        'should pass the model to the update function': function(Model) {
          var Derived, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          Derived.update = function(model) {
            return assert.equal(model, g);
          };
          return g.set('test', 500);
        },
        'should pass all of the model\'s data to the update function': function(Model) {
          var Derived, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          g.set('test', 500);
          Derived.update = function(model, data) {
            return assert.isTrue(true);
          };
          g.set('beam', 200);
          return assert.isTrue(true);
        },
        'should pass the current property name being changed to the update function': function(Model) {
          var Derived, g;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          g = new Derived();
          Derived.update = function(model, data, property) {
            return assert.equal(property, 'test');
          };
          return g.set('test', 500);
        },
        'should set prototype chain of subclasses': function(Model) {
          var Derived;
          Derived = Model.extend(function() {
            return Model.call(this);
          });
          return assert.isTrue(new Derived() instanceof Model);
        },
        'should make subclasses inherit class methods': function(Model) {
          var Derived;
          Derived = Model.extend(function() {
            return Model.call(this);
          });
          return assert.isTrue(Derived.validate != null);
        },
        'should set properties passed into constructor': function(Model) {
          var g;
          g = new Model({
            test: 500
          });
          return g.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should not set any properties in constructor if a required one is missing': function(Model) {
          var Derived, m;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.required('username');

            return _Class;

          })(Model);
          m = new Derived({
            test: 500
          });
          return m.get('test', function(err, value) {
            return assert.isNull(value);
          });
        },
        'should not set any properties in a `set` call if a required one is missing': function(Model) {
          var Derived, m;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.required('username');

            return _Class;

          })(Model);
          m = new Derived;
          m.set('test', 500);
          return m.get('test', function(err, value) {
            return assert.isNull(value);
          });
        },
        'should set default values if declared': function(Model) {
          var Derived, m;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.defaults({
              'test': 500
            });

            return _Class;

          })(Model);
          m = new Derived();
          return m.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should set default required values if declared': function(Model) {
          var Derived, m;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.required('test');

            _Class.defaults({
              'test': 500
            });

            return _Class;

          })(Model);
          m = new Derived();
          return m.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should call the class\'s `read` method if attempting to access an undefined property': function(Model) {
          var Derived, m;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            return callback(null, 500);
          };
          m = new Derived();
          return m.get('test', function(err, value) {
            return assert.equal(value, 500);
          });
        },
        'should call the class\'s `read` method if given properties with `has` and `loadAll` is called': function(Model) {
          var Derived, didRead, m;
          didRead = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.has('test');

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            didRead = true;
            return callback(null, 500);
          };
          m = new Derived();
          m.loadAll();
          return assert.isTrue(didRead);
        },
        'should call the `loadAll` callback when finished loading': function(Model) {
          var Derived, called, m;
          called = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.has('test1', 'test2');

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            return callback(null, 500);
          };
          m = new Derived();
          m.loadAll(function(err) {
            if (!err) return called = true;
          });
          return assert.isTrue(called);
        },
        'should only call the `loadAll` callback once after finishing': function(Model) {
          var Derived, called, m;
          called = 0;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.has('test1', 'test2');

            return _Class;

          })(Model);
          Derived.read = function(model, data, proeprty, callback) {
            return callback(null, 500);
          };
          m = new Derived();
          m.loadAll(function(err) {
            return called++;
          });
          return assert.equal(called, 1);
        },
        'should cache things loaded with `loadAll`': function(Model) {
          var Derived, m, numReads;
          numReads = 0;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.has('test');

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            numReads++;
            return callback(null, 500);
          };
          m = new Derived();
          m.loadAll();
          return m.get('test', function(err, value) {
            return assert.equal(numReads, 1);
          });
        },
        'should proxy out to the class\'s `destroy` method when using model.destroy()': function(Model) {
          var Derived, destroyed, m;
          destroyed = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.destroy = function(model, data, callback) {
            destroyed = true;
            return callback(null);
          };
          m = new Derived();
          return m.destroy(function(err) {
            return assert.isTrue(destroyed);
          });
        },
        'should proxy out to the class\'s `create` method when creating models': function(Model) {
          var Derived, created, m;
          created = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.create = function(model, data, callback) {
            created = true;
            return callback(null);
          };
          m = new Derived();
          return assert.isTrue(created);
        },
        'should not proxy out to the class\'s `update` method during instantiation': function(Model) {
          var Derived, m, updated;
          updated = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            _Class.defaults({
              test1: 200
            });

            function _Class() {
              _Class.__super__.constructor.call(this, {
                test2: 500
              });
            }

            return _Class;

          })(Model);
          Derived.update = function(model, data, property, callback) {
            updated = true;
            return callback(null);
          };
          m = new Derived();
          return assert.isFalse(updated);
        },
        'should not proxy out to the class\'s `update` method during a `get` load': function(Model) {
          var Derived, m, updated;
          updated = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            return callback(null, 500);
          };
          Derived.update = function(model, data, property, callback) {
            updated = true;
            return callback(null);
          };
          m = new Derived();
          return m.get('test', function(err, value) {
            return assert.isFalse(updated);
          });
        },
        'should not proxy out to the class\'s `update` method during a `loadAll` load': function(Model) {
          var Derived, m, updated;
          updated = false;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.has('test');

            return _Class;

          })(Model);
          Derived.read = function(model, data, property, callback) {
            return callback(null, 500);
          };
          Derived.update = function(model, data, property, callback) {
            updated = true;
            return callback(null);
          };
          m = new Derived();
          return m.loadAll(function(err) {
            return assert.isFalse(updated);
          });
        },
        'should return the string passed into a single-arg required call': function(Model) {
          var Derived;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.test = _Class.required('500');

            return _Class;

          })(Model);
          return assert.equal(Derived.test, '500');
        },
        'should create a default empty callback inside the instance destroy method if none was given': function(Model) {
          var Derived, d;
          Derived = (function(_super) {

            __extends(_Class, _super);

            function _Class() {
              _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(Model);
          Derived.destroy = function(model, data, callback) {
            assert.isTrue(typeof callback === 'function');
            return callback();
          };
          d = new Derived();
          return d.destroy();
        }
      }
    });
  };

}).call(this);
