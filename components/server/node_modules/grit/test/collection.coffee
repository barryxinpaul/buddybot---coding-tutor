vows = require 'vows'
assert = require 'assert'
grit = require '../index.js'
Collection = grit.Collection
Model = grit.Model
placeholder = grit.placeholder

exports = module.exports = (suite) ->
	suite.addBatch
		'Collections':
			topic: () -> Collection

			'should start empty': (Collection) ->
				collection = new Collection()
				assert.equal collection.length(), 0

			'should push to the back': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.push model
				equal = false
				collection.at 1, (err, m) ->
					equal =  m == model
				assert.isTrue equal

			'should pop from the back': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.push model
				collection.pop (err, m) ->
					assert.equal m, model

			'should mutate the collection to remove the object being popped': (Collection) ->
				collection = new Collection()
				model = new Model()
				collection.push model
				collection.pop (err, m) ->
					assert.equal collection.length(), 0

			'should push to the front when using pushFront': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.pushFront model
				collection.at 0, (err, m) ->
					assert.equal model, m

			'should pop from the front when using popFront': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.pushFront model
				collection.popFront (err, m) ->
					assert.equal model, m

			'should remove from the correct spot when using remove with an index': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.push model
				collection.push new Model()
				collection.remove 1, (err, m) ->
					assert.equal model, m

			'should remove the correct element when using remove with a model': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				model = new Model()
				collection.push model
				collection.push new Model()
				collection.remove model, (err, m) ->
					assert.equal model, m

			'remove should mutate the collection': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				collection.remove 0
				assert.equal collection.length(), 0

			'should iterate over everything when not specifying an ordering': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				collection.push new Model()
				numModels = 0
				collection.forEach (err, model) ->
					numModels++
				assert.equal numModels, collection.length()

			'should iterate over everything when specifying an ordering': (Collection) ->
				collection = new Collection()
				collection.push new Model()
				collection.push new Model()
				numModels = 0
				collection.forEach {inOrder:true}, (err, model) ->
					numModels++
				assert.equal numModels, collection.length()

			'should pass the correct indices when iterating async': (Collection) ->
				collection = new Collection()
				m0 = new Model()
				m1 = new Model()
				collection.push m0
				collection.push m1
				correctIndex = true
				collection.forEach (err, model, index) ->
					correctIndex = correctIndex && if model == m0 then index == 0 else index == 1
				assert.isTrue correctIndex

			'should forward any change events from the model': (Collection) ->
				collection = new Collection()
				m = new Model()
				collection.push m
				forwarded = false
				collection.on 'change:test', (model, oldValue, newValue) ->
					forwarded = true
				m.set 'test', 500
				assert.isTrue forwarded

			'should forward the generic property change events': (Collection) ->
				collection = new Collection()
				m = new Model()
				collection.push m
				forwarded = false
				collection.on 'propertyChange', (evt) ->
					forwarded = true if evt == 'change:test'
				m.set 'test', 500
				assert.isTrue forwarded

			'should emit add events when things are added': (Collection) ->
				collection = new Collection()
				emitted = false
				collection.on 'add', ->
					emitted = true
				collection.push new Model()
				assert.isTrue emitted

			'should pass the right model to add events': (Collection) ->
				collection = new Collection()
				m = new Model()
				emitted = false
				collection.on 'add', (model) ->
					emitted = true if model == m
				collection.push m
				assert.isTrue emitted

			'should emit remove events when things are removed': (Collection) ->
				collection = new Collection()
				emitted = false
				collection.on 'remove', ->
					emitted = true
				collection.push new Model()
				collection.remove 0
				assert.isTrue emitted

			'should pass the right model to remove events': (Collection) ->
				collection = new Collection()
				m = new Model()
				emitted = false
				collection.on 'remove', (model) ->
					emitted = true if model == m
				collection.push m
				collection.remove 0
				assert.isTrue emitted
