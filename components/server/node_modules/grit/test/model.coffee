vows = require 'vows'
assert = require 'assert'
grit = require '../index.js'
Model = grit.Model

exports = module.exports = (suite) ->
	suite.addBatch
		'Model objects':
			topic: () -> Model
			
			'should return null for uninitialized data': (Model) ->
				g = new Model()
				g.get 'test', (err, value) ->
					assert.equal value, null
			
			'should return the correct data when accessing previously set data': (Model) ->
				g = new Model()
				g.set 'test', 500
				g.get 'test', (err, value) ->
					assert.equal value, 500

			'should fire change events when setting data': (Model) ->
				g = new Model()
				called = false
				g.on 'change:test', () ->
					called = true
				g.set 'test', 500
				assert.isTrue called

			'should not fire unrelated change events when setting data': (Model) ->
				g = new Model()
				called = false
				g.on 'change:nope', () ->
					called = true
				g.set 'test', 500
				assert.isFalse called

			'should pass the model into change handlers as the first argument': (Model) ->
				g = new Model()
				g.on 'change:test', (model) ->
					assert.equal model, g
				g.set 'test', 500

			'should pass the old value into change handlers as the second argument': (Model) ->
				g = new Model()
				g.on 'change:test', (model, oldValue) ->
					assert.equal oldValue, null
				g.set 'test', 500

			'should pass the new value into change handlers as the third argument': (Model) ->
				g = new Model()
				g.on 'change:test', (model, oldValue, value) ->
					assert.equal value, 500
				g.set 'test', 500

			'should change the old value prior to a change callback': (Model) ->
				g = new Model()
				g.on 'change:test', (model) ->
					model.get 'test', (err, value) ->
						assert.notEqual value, null
				g.set 'test', 500

			'should change the property after the change callback': (Model) ->
				g = new Model()
				g.on 'change:test', () ->
				g.set 'test', 500
				g.get 'test' , (err, value) ->
					assert.equal value, 500

			'should not emit the change event if a truthy value is passed as the silent parameter to set': (Model) ->
				g = new Model()
				called = false
				g.on 'change:test', () ->
					called = true
				g.set 'test', 500, true
				assert.isFalse called

			'should fire the generic propertyChanged event on every property change': (Model) ->
				g = new Model()
				called = 0
				g.on 'propertyChange', () ->
					called++
				g.set 'test', 500
				g.set 'test2', 200
				assert.equal called, 2

			'should pass the right event names into the generic propertyChanged handlers': (Model) ->
				g = new Model()
				g.on 'propertyChange', (evt) ->
					assert.equal evt, 'change:test'
				g.set 'test', 500

			'should call validation functions when associated data is changed': (Model) ->
				called = false
				Derived = class extends Model
				Derived.validate 'test', (value) ->
					called = true
				g = new Derived()
				g.set 'test', 500
				assert.isTrue called

			'should change the value being set if the validation function returns true': (Model) ->
				Derived = class extends Model
				g = new Derived()
				Derived.validate 'test', (value) -> true
				g.set 'test', 500
				g.get 'test', (err, value) ->
					assert.equal value, 500

			'should not change the value being set if the validation function returns false': (Model) ->
				Derived = class extends Model
				g = new Derived()
				Derived.validate 'test', (value) -> false
				g.set 'test', 500
				g.get 'test', (err, value) ->
					assert.isNull value

			'should call the update function after setting data': (Model) ->
				Derived = class extends Model
				g = new Derived()
				called = false
				Derived.update = () ->
					called = true
				g.set 'test', 500
				assert.isTrue called

			'should pass the model to the update function': (Model) ->
				Derived = class extends Model
				g = new Derived()
				Derived.update = (model) ->
					assert.equal model, g
				g.set 'test', 500

			'should pass all of the model\'s data to the update function': (Model) ->
				Derived = class extends Model
				g = new Derived()
				g.set 'test', 500
				Derived.update = (model, data) ->
					assert.isTrue true
				g.set 'beam', 200
				assert.isTrue true

			'should pass the current property name being changed to the update function': (Model) ->
				Derived = class extends Model
				g = new Derived()
				Derived.update = (model, data, property) ->
					assert.equal property, 'test'
				g.set 'test', 500

			'should set prototype chain of subclasses': (Model) ->
				Derived = Model.extend () ->
					Model.call this
				assert.isTrue (new Derived() instanceof Model)

			'should make subclasses inherit class methods': (Model) ->
				Derived = Model.extend () ->
					Model.call this
				assert.isTrue Derived.validate?

			'should set properties passed into constructor': (Model) ->
				g = new Model test:500
				g.get 'test', (err, value) ->
					assert.equal value, 500

			'should not set any properties in constructor if a required one is missing': (Model) ->
				Derived = class extends Model
					@required 'username'
				m = new Derived test:500
				m.get 'test', (err, value) ->
					assert.isNull value

			'should not set any properties in a `set` call if a required one is missing': (Model) ->
				Derived = class extends Model
					@required 'username'
				m = new Derived
				m.set 'test', 500
				m.get 'test', (err, value) ->
					assert.isNull value

			'should set default values if declared': (Model) ->
				Derived = class extends Model
					@defaults 'test': 500
				m = new Derived()
				m.get 'test', (err, value) ->
					assert.equal value, 500

			'should set default required values if declared': (Model) ->
				Derived = class extends Model
					@required 'test'
					@defaults 'test': 500
				m = new Derived()
				m.get 'test', (err, value) ->
					assert.equal value, 500

			'should call the class\'s `read` method if attempting to access an undefined property': (Model) ->
				Derived = class extends Model
				Derived.read = (model, data, property, callback) ->
					callback null, 500
				m = new Derived()
				m.get 'test', (err, value) ->
					assert.equal value, 500


			'should call the class\'s `read` method if given properties with `has` and `loadAll` is called': (Model) ->
				didRead = false
				Derived = class extends Model
					@has 'test'
				Derived.read = (model, data, property, callback) ->
					didRead = true
					callback null,  500
				m = new Derived()
				m.loadAll()
				assert.isTrue didRead

			'should call the `loadAll` callback when finished loading': (Model) ->
				called = false
				Derived = class extends Model
					@has 'test1', 'test2'
				Derived.read = (model, data, property, callback) ->
					callback null, 500
				m = new Derived()
				m.loadAll (err) ->
					unless err
						called = true
				assert.isTrue called

			'should only call the `loadAll` callback once after finishing': (Model) ->
				called = 0
				Derived = class extends Model
					@has 'test1', 'test2'
				Derived.read = (model, data, proeprty, callback) ->
					callback null, 500
				m = new Derived()
				m.loadAll (err) ->
					called++
				assert.equal called, 1

			'should cache things loaded with `loadAll`': (Model) ->
				numReads = 0
				Derived = class extends Model
					@has 'test'
				Derived.read = (model, data, property, callback) ->
					numReads++
					callback null, 500
				m = new Derived()
				m.loadAll()
				m.get 'test', (err, value) ->
					assert.equal numReads, 1

			'should proxy out to the class\'s `destroy` method when using model.destroy()': (Model) ->
				destroyed = false
				Derived = class extends Model
				Derived.destroy = (model, data, callback) ->
					destroyed = true
					callback(null)
				m = new Derived()
				m.destroy (err) ->
					assert.isTrue destroyed

			'should proxy out to the class\'s `create` method when creating models': (Model) ->
				created = false
				Derived = class extends Model
				Derived.create = (model, data, callback) ->
					created = true
					callback null
				m = new Derived()
				assert.isTrue created

			'should not proxy out to the class\'s `update` method during instantiation': (Model) ->
				updated = false
				Derived = class extends Model
					@defaults test1: 200
					constructor: ->
						super test2: 500
				Derived.update = (model, data, property, callback) ->
					updated = true
					callback null

				m = new Derived()
				assert.isFalse updated

			'should not proxy out to the class\'s `update` method during a `get` load': (Model) ->
				updated = false
				Derived = class extends Model
				Derived.read = (model, data, property, callback) ->
					callback null, 500
				Derived.update = (model, data, property, callback) ->
					updated = true
					callback null

				m = new Derived()
				m.get 'test', (err, value) ->
					assert.isFalse updated

			'should not proxy out to the class\'s `update` method during a `loadAll` load': (Model) ->
				updated = false
				Derived = class extends Model
					@has 'test'
				Derived.read = (model, data, property, callback) ->
					callback null, 500
				Derived.update = (model, data, property, callback) ->
					updated = true
					callback null

				m = new Derived()
				m.loadAll (err) ->
					assert.isFalse updated

			'should return the string passed into a single-arg required call': (Model) ->
				Derived = class extends Model
					@test = @required '500'

				assert.equal Derived.test, '500'
			
			'should create a default empty callback inside the instance destroy method if none was given': (Model) ->
				Derived = class extends Model
				Derived.destroy = (model, data, callback) ->
					assert.isTrue typeof callback == 'function'
					callback()
				d = new Derived()
				d.destroy()

